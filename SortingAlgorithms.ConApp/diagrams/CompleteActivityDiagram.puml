@startuml CompleteActivityDiagram
header
generated on 09/04/2024 14:47:08
end header
title CompleteActivityDiagram
start
note right:  Program.Main
#LightGreen:Params(string[] args);
#LightSkyBlue:int TEST_SIZE = 20\nint PERFORMANCE_SIZE = 50_000\nint[] array;
#WhiteSmoke:PrintLine("Sort-Algorithmen!");
#WhiteSmoke:PrintLine("=================");
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Test BruteForceSort");
#WhiteSmoke:array = CreateRandomArray(TEST_SIZE);
#WhiteSmoke:PrintArray("Unsorted:", array);
#WhiteSmoke:Sort.BruteForceSort(array);
#WhiteSmoke:PrintArray("BruteForceSort:", array);
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Test BubbleSort");
#WhiteSmoke:array = CreateRandomArray(TEST_SIZE);
#WhiteSmoke:PrintArray("Unsorted:", array);
#WhiteSmoke:Sort.BubbleSort(array);
#WhiteSmoke:PrintArray("BubbleSort:", array);
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Test InsertionSort");
#WhiteSmoke:array = CreateRandomArray(TEST_SIZE);
#WhiteSmoke:PrintArray("Unsorted:", array);
#WhiteSmoke:Sort.InsertionSort(array);
#WhiteSmoke:PrintArray("InsertionSort:", array);
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Test SelectionSort");
#WhiteSmoke:array = CreateRandomArray(TEST_SIZE);
#WhiteSmoke:PrintArray("Unsorted:", array);
#WhiteSmoke:Sort.SelectionSort(array);
#WhiteSmoke:PrintArray("SelectionSort:", array);
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Performance Testing");
#WhiteSmoke:PrintLine("===================");
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Machine:   " + Environment.MachineName);
#WhiteSmoke:PrintLine("Version:   " + Environment.Version);
#WhiteSmoke:PrintLine("Processor: Apple M2");
#WhiteSmoke:PrintLine("Processor: " + Environment.ProcessorCount + " cores");
#WhiteSmoke:PrintLine("OS:        " + Environment.OSVersion);
#WhiteSmoke:PrintLine();
#LightSkyBlue:Stopwatch sw = new Stopwatch()\nint[] randomArray = CreateRandomArray(PERFORMANCE_SIZE)\nint[] arrayToSort;
#WhiteSmoke:arrayToSort = (int[])randomArray.Clone();
#WhiteSmoke:PrintLine($"{nameof(Sort.BruteForceSort)}(0...{randomArray.Length})");
#WhiteSmoke:sw.Start();
#WhiteSmoke:Sort.BruteForceSort(arrayToSort);
#WhiteSmoke:sw.Stop();
#WhiteSmoke:PrintLine($"Zeitmessung: {sw.ElapsedMilliseconds} ms");
#WhiteSmoke:PrintLine();
#WhiteSmoke:arrayToSort = (int[])randomArray.Clone();
#WhiteSmoke:PrintLine($"{nameof(Sort.BubbleSort)}(0...{randomArray.Length})");
#WhiteSmoke:sw.Restart();
#WhiteSmoke:Sort.BubbleSort(arrayToSort);
#WhiteSmoke:sw.Stop();
#WhiteSmoke:PrintLine($"Zeitmessung: {sw.ElapsedMilliseconds} ms");
#WhiteSmoke:PrintLine();
#WhiteSmoke:arrayToSort = (int[])randomArray.Clone();
#WhiteSmoke:PrintLine($"{nameof(Sort.InsertionSort)}(0...{randomArray.Length})");
#WhiteSmoke:sw.Restart();
#WhiteSmoke:Sort.InsertionSort(arrayToSort);
#WhiteSmoke:sw.Stop();
#WhiteSmoke:PrintLine($"Zeitmessung: {sw.ElapsedMilliseconds} ms");
#WhiteSmoke:PrintLine();
#WhiteSmoke:arrayToSort = (int[])randomArray.Clone();
#WhiteSmoke:PrintLine($"{nameof(Sort.SelectionSort)}(0...{randomArray.Length})");
#WhiteSmoke:sw.Restart();
#WhiteSmoke:Sort.SelectionSort(arrayToSort);
#WhiteSmoke:sw.Stop();
#WhiteSmoke:PrintLine($"Zeitmessung: {sw.ElapsedMilliseconds} ms");
#WhiteSmoke:PrintLine();
#WhiteSmoke:arrayToSort = (int[])randomArray.Clone();
#WhiteSmoke:PrintLine($"Array.Sort(0...{randomArray.Length})");
#WhiteSmoke:sw.Restart();
#WhiteSmoke:Array.Sort(arrayToSort);
#WhiteSmoke:sw.Stop();
#WhiteSmoke:PrintLine($"Zeitmessung: {sw.ElapsedMilliseconds} ms");
#WhiteSmoke:PrintLine();
#WhiteSmoke:PrintLine("Exit with ENTER...");
#WhiteSmoke:ReadLine();
stop
start
note right:  Program.PrintArray
#LightGreen:Params(string title,int[] array);
#WhiteSmoke:PrintLine(title);
#WhiteSmoke:PrintArray(array);
stop
start
note right:  Program.PrintArray
#LightGreen:Params(int[] array);
#LightSkyBlue:int i = 0;
while (i < array.Length) is (<color:green>yes)
        if (i > 0) then (<color:green>yes)
                #WhiteSmoke:Print(" ");
        endif
        #WhiteSmoke:Print(array[i]);
:i++;
endwhile (<color:red>no)
#WhiteSmoke:PrintLine();
stop
start
note right:  Program.CreateRandomArray
#LightGreen:Params(int size);
#Lavender:return CreateRandomArray(size, 0, size);
stop
start
note right:  Program.CreateRandomArray
#LightGreen:Params(int size,int min,int max);
#LightSkyBlue:int[] result = new int[size];
#LightSkyBlue:int i = 0;
while (i < result.Length) is (<color:green>yes)
        #WhiteSmoke:result[i] = Random.Shared.Next(min, max);
:i++;
endwhile (<color:red>no)
#Lavender:return result;
stop
start
note right:  Sort.BruteForceSort
#LightGreen:Params(int[] array);
#LightSkyBlue:int i = 0;
while (i < array.Length) is (<color:green>yes)
        #LightSkyBlue:int j = 0;
        while (j < array.Length - 1) is (<color:green>yes)
                if (array[j] > array[j + 1]) then (<color:green>yes)
                        #WhiteSmoke:Swap(ref array[j], ref array[j + 1]);
                endif
        :j++;
        endwhile (<color:red>no)
:i++;
endwhile (<color:red>no)
stop
start
note right:  Sort.BubbleSort
#LightGreen:Params(int[] array);
#LightSkyBlue:bool exchange\nint length = array.Length;
repeat
        #WhiteSmoke:exchange = false;
        #LightSkyBlue:int i = 0;
        while (i < length - 1) is (<color:green>yes)
                if (array[i] > array[i + 1]) then (<color:green>yes)
                        #WhiteSmoke:Swap(ref array[i], ref array[i + 1]);
                        #WhiteSmoke:exchange = true;
                endif
        :i++;
        endwhile (<color:red>no)
        #WhiteSmoke:length--;
repeat while (exchange) is (<color:green>yes)
stop
start
note right:  Sort.InsertionSort
#LightGreen:Params(int[] array);
#LightSkyBlue:int i = 1;
while (i < array.Length) is (<color:green>yes)
        #LightSkyBlue:int j = i;
        #LightSkyBlue:int current = array[i];
        while (j > 0 && array[j - 1] > current) is (<color:green>yes)
                #WhiteSmoke:array[j] = array[j - 1];
                #WhiteSmoke:j--;
        endwhile (<color:red>no)
        #WhiteSmoke:array[j] = current;
:i++;
endwhile (<color:red>no)
stop
start
note right:  Sort.SelectionSort
#LightGreen:Params(int[] array);
#LightSkyBlue:int i = 0;
while (i < array.Length - 1) is (<color:green>yes)
        #LightSkyBlue:int minIdx = i;
        #LightSkyBlue:int j = i + 1;
        while (j < array.Length) is (<color:green>yes)
                if (array[j] < array[minIdx]) then (<color:green>yes)
                        #WhiteSmoke:minIdx = j;
                endif
        :j++;
        endwhile (<color:red>no)
        if (minIdx != i) then (<color:green>yes)
                #WhiteSmoke:Swap(ref array[i], ref array[minIdx]);
        endif
:i++;
endwhile (<color:red>no)
stop
start
note right:  Sort.Swap
#LightGreen:Params(ref int v1,ref int v2);
#LightSkyBlue:int tmp = v1;
#WhiteSmoke:v1 = v2;
#WhiteSmoke:v2 = tmp;
stop
footer
generated with the DiagramCreator by Prof.Gehrer
end footer
@enduml
